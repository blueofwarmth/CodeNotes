# RPC

功能:

代理层

注册中心

路由层

故障转移

协议层

拦截器层

SPI

**核心职责** 技术+场景+效果



## 前言

本视频内容以 原理为主，代码为辅，自主思考较多。

讲解顺序：架构-设计-代码

## 基本概念

远程过程调用（RPC）是一种通信机制，允许一个计算机程序调用另一个计算机上的子程序或函数，而不需要了解底层网络细节。这种机制使得分布式系统中的不同部分能够像调用本地函数一样进行通信。

在RPC中，调用方（通常是客户端）发起一个调用请求，请求包含了要调用的远程函数的标识符以及参数。这个请求通过网络发送到远程计算机上的RPC服务器。服务器接收到请求后，执行相应的函数，并将结果返回给调用方。

RPC系统通常由以下几个组件构成：

1. **客户端（Client）**：发起RPC调用的程序或模块。
2. **服务器（Server）**：接收RPC请求并执行相应的远程函数的程序或模块。
3. **Stub**：客户端和服务器之间的本地代理，用于封装RPC调用。客户端stub将RPC调用转换成网络消息并发送给服务器，服务器stub接收消息并调用本地函数。
4. **协议**：定义了通信格式和规则，如数据的编码方式、消息的格式等。
5. **传输协议**：确定了消息在网络上传输的方式，可以是TCP、UDP、HTTP等。

RPC的一个重要特性是透明性，即调用远程函数的过程对于调用方来说是透明的，就好像调用本地函数一样。这使得在分布式系统中构建和使用远程服务更加方便。

### RPC和HTTP的区别？

HTTP（Hypertext Transfer Protocol）和RPC（Remote Procedure Call）是两种不同的通信协议，用于不同的目的和场景。

1. **HTTP (Hypertext Transfer Protocol)**:
   - HTTP是一种用于传输超文本（如HTML）数据的应用层协议。
   - 它是基于客户端-服务器模型的，客户端发送HTTP请求，服务器端响应该请求。
   - HTTP通常用于Web浏览器和Web服务器之间的通信，以获取和显示网页内容。
   - HTTP是无状态的，每个请求都是独立的，服务器不保留与客户端之间的任何状态信息。

2. **RPC (Remote Procedure Call)**:
   - RPC是一种远程过程调用协议，允许一个程序调用另一个程序上的子程序或函数，就像调用本地函数一样。
   - 它的目的是使分布式系统中的不同进程能够像调用本地函数一样进行通信。
   - RPC隐藏了底层的网络通信细节，使得远程调用看起来像是本地调用一样简单。
   - RPC可以使用各种传输协议，例如TCP/IP、HTTP等。

主要区别在于它们的使用场景和设计目的。HTTP主要用于传输Web内容，而RPC主要用于在分布式系统中进行远程过程调用。HTTP是一种通用的协议，RPC是一种更专用的协议，用于特定的应用领域。

## RPC演变以及架构

### 普通调用

中间通过协议

协议主要解决粘包/半包和序列化的问题

![image-20240506145318029](https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202405061453114.png)

### 引用注册中心

![image-20240506145354767](https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202405061453831.png)

### 加入负载均衡

如果A服务挂了, 可以去找其他服务

序列化如何表示?

![image-20240506145425100](https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202405061454172.png)

### 加入编码和序列化

![image-20240506145523263](https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202405061455348.png)

### 加入验证

拦截器中可以提供一些额外的行为

比如调用验证

当前的架构都在代码中写死了, 如果后续要提供拓展, 会很复杂

![image-20240506145659547](https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202405061456630.png)

### SPI动态加载

将类配置在SPI 中, 动态的加载, 类似spring中的ioc



![image-20240506145852273](https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202405061458391.png)

### 加入故障转移

发起调用后如果调用失败, 走到容错机制中, 根据不同场景选择不同的策略

![image-20240506150118893](https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202405061501021.png)

## 网络通信核心层 - 协议

### 粘包/半包

**粘包:** 发送数据时, 会将数据放到缓冲区当中, 然后统一读取. 这时候如果发送多条数据就会当成一条数据处理

**处理:** 发送数据时也带上数据长度信息, 读取时根据长度读取

**半包:** 发送数据长度超过 缓冲区大小, 接收时没有完整收到数据

**处理:**

### 对象传输

Object -> JSON 

我们指定一个传输协议, 解决粘包/半包

![image-20240527200151921](https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202405272001979.png)

### netty

包装协议去传输

Promise 和 Future 是并发编程中常用的两个概念，它们常用于处理异步操作。以下是它们的定义和区别：

### Promise
Promise 是一种编程模式，用于表示一个异步操作的结果。它有以下几个关键特性：
- **状态**：Promise 有三种状态：Pending（进行中）、Fulfilled（已完成）和 Rejected（已失败）。
- **值**：当 Promise 状态为 Fulfilled 时，会有一个对应的值；当状态为 Rejected 时，会有一个对应的原因（错误信息）。
- **操作**：Promise 提供 `.then()` 方法来处理已完成或已失败的结果，并提供 `.catch()` 方法来处理错误。

Promise 的核心在于它可以将异步操作的结果封装起来，并通过链式调用处理后续操作。

### Future
Future 是一个与 Promise 类似的概念，但它通常用于表示一个值或错误，它将在将来的某个时刻被设置。Future 也有不同的实现方式，但总体上有以下特点：
- **获取结果**：Future 通常提供方法来获取异步操作的结果，一般是一个阻塞的 `get()` 方法，直到结果可用。
- **不可变性**：一旦 Future 的结果被设置，它就不可变了。

### 区别
1. **主动与被动**：
   - Promise 是主动的，它允许你主动设置结果（通过 `resolve` 或 `reject`）。
   - Future 是被动的，它通常是由某个异步操作的完成来设置结果，你不能主动设置 Future 的结果。

2. **模式**：
   - Promise 更常用于 JavaScript 等编程语言，支持链式调用和异步处理。
   - Future 在 Java 和其他一些语言中更为常见，通常与线程和并发处理有关。

3. **方法和使用方式**：
   - Promise 提供了丰富的方法如 `then`、`catch` 和 `finally`，使得处理异步操作更加方便和直观。
   - Future 通常有 `get`、`isDone` 等方法，偏向于在完成时直接获取结果，可能涉及阻塞调用。

### 举例
在 JavaScript 中使用 Promise：

```javascript
let promise = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve("Success!");
    }, 1000);
});

promise.then(result => {
    console.log(result); // 输出 "Success!"
}).catch(error => {
    console.error(error);
});
```

在 Java 中使用 Future：

```java
import java.util.concurrent.*;

public class FutureExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newSingleThreadExecutor();
        Future<String> future = executor.submit(() -> {
            Thread.sleep(1000);
            return "Success!";
        });

        try {
            String result = future.get(); // 阻塞直到结果可用
            System.out.println(result); // 输出 "Success!"
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        } finally {
            executor.shutdown();
        }
    }
}
```

总的来说，Promise 和 Future 是处理异步编程的重要工具，它们各自有不同的实现和使用场景。Promise 更加灵活和现代化，适用于链式异步处理，而 Future 更传统，通常用于并发任务的结果获取。

## 代理层

**代理设计模式**

代理设计模式是一种结构型设计模式，它允许你提供一个替代品或占位符，以控制对其他对象的访问。

在代理模式中，有三种主要角色：

1. **主题（Subject）**：定义了真实对象和代理对象共同的接口，客户端通过这个接口访问真实对象。
2. **真实主题（Real Subject）**：实现了主题接口，定义了代理所代表的真实对象。
3. **代理（Proxy）**：保存一个引用使得代理可以访问真实主题，并提供一个与真实主题接口相同的接口，以便于客户端访问真实主题，同时可以在访问真实主题前后进行一些额外的操作。

代理模式可以应用于各种场景中，比如：

- **远程代理**：用于控制对远程对象的访问。
- **虚拟代理**：用于控制对大对象的访问，只有在需要时才创建真实对象。
- **保护代理**：用于控制对真实对象的访问权限。
- **缓存代理**：用于缓存访问结果，避免重复计算。

代理模式的优点包括：

- **远程代理**：可以隐藏对象存在于不同地址空间的事实。
- **虚拟代理**：可以减少真实对象的创建和销毁开销。
- **保护代理**：可以控制对真实对象的访问权限。
- **缓存代理**：可以提高访问速度。

代理模式的缺点包括：

- 增加了系统的复杂性，因为引入了额外的间接层。
- 可能会降低系统的性能，因为需要额外的处理来管理代理对象的生命周期和调用转发。

总的来说，**代理模式可以帮助我们在不改变原始对象的情况下，控制对其访问的方式，从而实现一些额外的功能。**

在 RPC（远程过程调用）架构中，代理层通常用于封装客户端和服务器之间的通信细节，并提供给客户端一个透明的接口，使得客户端可以像调用本地函数一样调用远程函数。

例如：制定协议，编码，从注册中心要服务，负载均衡，调用，容错机制。所有的流程都在代理层中封装好了。调用方只需要进行调用方法即可。

>   在mybatis中的mapper层也是如此

## 注册中心

>   这一小节讲解：服务注册/发现过程，配置文件，以redis为角度讲解注册中心

用于提供服务注册以及服务发现功能。

提供方将服务提供给注册中心

调用方进行服务发现时给具体的接口创建代理对象，封装逻辑。服务发现(依赖注入)

### ProviderPsotProcessor

#### 启动服务

#### netty服务

#### 服务注册

* 获取RpcService注解
* 服务从配置文件注册到ioc中

#### 设置配置文件

### ConsumerPostProcessor

#### 从配置文件中读取信息

#### 初始化始化bean

* 序列化
* 注册工厂
* 负载均衡
* 过滤器

#### 初始化后的后期处理

* 获取RpcReference注解

* 创建代理对象

### zekpper

* 存储形式

![image-20240529120514440](https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202405291205543.png)

* 支持永久和临时
* 这里采用临时, 服务下线时删除
* 持续监听目录下的服务状态

![image-20240529122411632](https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202405291224728.png)

### Redis注册中心

```
*      使用集合保存所有服务节点信息
* 1. 服务启动：节点使用了redis作为注册中心后，将自身信息注册到redis当中(ttl：10秒)，并开启定时任务，ttl/2。
* 2. 定时任务用于检测各个节点的信息，如果发现节点的时间 < 当前时间->则将节点踢出，如果没有发现->则续签自身节点
* 3. 将节点踢出后，从服务注册表中找到对应key删除该节点的下的服务数据信息
*
* ttl :10秒
* 定时任务为ttl/2
*节点注册后启动心跳检测，检测服务注册的key集合，如果有服务到期，则删除,自身的服务则续签
* 服务注册后将服务注册到redis以及保存到自身的服务注册key集合，供心跳检测
*
* 如果有节点宕机，则其他服务会检测的，如果服务都宕机，则ttl会进行管理
```

## 路由层

在负载均衡算法中，可以将它们分为动态和静态两类，具体分类如下：

**动态负载均衡算法**：
1. **最小连接数（Least Connections）**：根据当前连接数最少的服务器来分配请求。
2. **加权最小连接数（Weighted Least Connections）**：根据服务器的权重和当前连接数来分配请求。
3. **最短响应时间（Least Response Time）**：根据服务器的响应时间来选择处理请求的服务器。
4. **一致性哈希（Consistent Hashing）**：根据请求的哈希值在环上顺时针查找到对应的服务器。

这些算法被称为动态负载均衡算法，因为它们需要实时监测服务器状态或请求情况，并根据这些信息动态地调整负载均衡策略。

**静态负载均衡算法**：

1. **轮询（Round Robin）**：依次将请求分配给每个服务器。
2. **加权轮询（Weighted Round Robin）**：根据服务器的权重依次将请求分配给每个服务器。
3. **随机（Random）**：随机选择一个服务器来处理请求。
4. **IP哈希（IP Hashing）**：根据客户端的IP地址计算哈希值，然后将请求分配给对应哈希值的服务器。

这些算法被称为静态负载均衡算法，因为它们在分配请求时不需要考虑服务器的状态或请求情况，分配策略是固定的，不会随着时间或系统负载的变化而改变。

通常，静态负载均衡算法更简单，适用于服务器性能相对稳定的场景；而动态负载均衡算法更复杂，但可以更灵活地根据实时情况调整负载均衡策略，适用于动态变化的负载均衡环境。

### 一致性哈希

* TreeMap构建hash环
* 计算MD5hash值
* 将哈希字节数组转换为long类型

## 协议层

![image-20240506172946261](https://myphoto-1301444197.cos.ap-chengdu.myqcloud.com/img/202405061729365.png)

* 魔数 通常是指在数据结构或文件格式中的特定值或标识符，用于识别文件类型、数据格式或数据结构。魔数可以用来验证文件的完整性、正确性和合法性。
* 状态 请求是否成功
* 序列化长度  根据长度读取具体是那种序列化
* 请求体数据长度 根据长度读取请求体
  * 长度不够不读
  * 长度溢出只读规定的

服务与服务之间进行通信需要制定好双方协议，是为了安全校验，状态显示，粘包半包等。

为了跨平台存储以及网络传输因此需要序列化。

在传输时也会出现粘包半包问题，也需要解决。

### 粘包&半包

粘包（Packet Congestion）和半包（Half Packet）是在网络通信中常见的问题，特别是在使用基于流（stream）传输数据的情况下。

**粘包**：

粘包指的是多个数据包在网络通信中被合并成一个数据包传输的现象。这通常发生在发送方连续发送多个小数据包时，由于网络传输的不确定性，这些小数据包可能会被合并成一个大数据包，到达接收方时需要进行拆分，从而导致接收方无法准确地解析出每个原始数据包。

**半包**：

半包指的是接收方无法完整地接收到一个数据包的情况。这通常发生在接收方在一次网络传输中无法一次性接收到完整的数据包，可能只接收到了部分数据包的情况。这可能是由于网络传输延迟、数据包丢失、网络拥塞等原因导致的。

解决粘包和半包问题的方法有多种，包括：

1. **消息定界符**：在数据包中使用特殊的定界符（如换行符 `\n`、回车符 `\r` 等）来标识消息的结束，接收方根据定界符进行数据包的切分。

2. **消息长度字段**：在数据包的头部添加一个表示数据包长度的字段，接收方首先读取该字段，然后根据长度信息读取相应长度的数据，从而准确地切分数据包。

3. **固定长度消息**：规定每个数据包的长度固定，发送方将数据分割成固定长度的数据包发送，接收方每次接收固定长度的数据进行处理。

4. **使用应用层协议**：设计应用层协议，明确定义数据包的格式和规则，使得发送方和接收方都能够按照规定的方式进行数据包的处理。

选择合适的解决方案取决于具体的网络通信场景和需求。





## 拦截器层

在服务发送前后以及服务接收前后可进行一系列的拦截操作，或者是增强行为等。这是一个拓展机制。

在责任链模式中，多个对象（处理器）依次处理同一个请求，直到其中一个对象处理成功为止。这些对象按照一定的顺序组成一条链，请求沿着链传递，直到被处理为止。

责任链模式通常包括以下几个角色：

1. **处理器（Handler）接口**：定义了处理请求的方法，并且通常包含一个指向下一个处理器的引用。处理器接口可以是抽象类或接口。

2. **具体处理器（ConcreteHandler）**：实现了处理器接口，负责处理特定类型的请求。如果自身无法处理请求，则将请求传递给下一个处理器。

3. **客户端（Client）**：创建并向责任链的第一个处理器发送请求。

责任链模式的优点包括：

- **降低耦合度**：请求者和处理者之间的关系解耦，每个处理器只需关注自己能够处理的请求类型。
- **灵活性**：可以动态地调整和扩展责任链，增加、移除或修改处理器的顺序。
- **可重用性**：处理器之间的关系是松散的，可以重用现有的处理器来构建不同的责任链。

但责任链模式也有一些缺点：

- **请求过长**：责任链过长可能会导致请求需要遍历整个链才能得到处理，影响性能。
- **请求未处理**：如果责任链中没有一个处理器能够处理请求，请求可能会被丢弃或者无法得到处理。

总的来说，责任链模式适用于需要动态地处理不同类型请求，并且请求的处理顺序不确定的情况。

## SPI

SPI（Service Provider Interface）机制是Java提供的一种服务发现机制，用于在运行时动态地加载和注册服务提供者实现，并通过接口进行统一调用。SPI机制主要用于解耦服务接口和具体实现，使得系统更加灵活和可扩展。

在SPI机制中，有三个核心角色：

1. **服务接口（Service Interface）**：定义了服务的抽象接口，是服务提供者实现的契约。

2. **服务提供者接口（Service Provider Interface）**：实现了服务接口的具体实现，并通过配置文件等方式将自己注册到系统中。服务提供者是 SPI 机制中的另一个核心角色，它提供了服务接口的具体实现。

3. **服务提供者（Service Provider）**：实现了服务接口的具体实现，同时通过配置文件等方式将自己注册到系统中。

SPI机制的基本流程如下：

1. 定义服务接口。
2. 定义服务提供者接口，服务提供者实现这个接口。
3. 在资源路径（META-INF/services/）下创建一个以服务接口全限定名为名字的文件，在文件中写入服务提供者的全限定名。
4. 使用`ServiceLoader`类加载并获取服务提供者的实例。

举个例子，假设有一个服务接口`com.example.Service`，服务提供者实现了这个接口，全限定名为`com.example.impl.ServiceImpl`，那么在`META-INF/services/`目录下创建一个名为`com.example.Service`的文件，文件内容为`com.example.impl.ServiceImpl`。然后可以使用以下代码获取服务提供者的实例：

```java
import java.util.ServiceLoader;
import com.example.Service;

public class Main {
    public static void main(String[] args) {
        ServiceLoader<Service> loader = ServiceLoader.load(Service.class);
        for (Service service : loader) {
            service.doSomething();
        }
    }
}
```

SPI机制在Java中被广泛应用，例如Java的JDBC驱动加载、JDK的`java.util.ServiceLoader`等。它使得系统的组件之间的依赖关系更加灵活，能够实现插拔式的组件替换和扩展。

### 实现

#### 两种加载模式

* 根据key获取类
* 根据接口获取接口子类

#### 根据spi机制初加载bean的信息放入map

